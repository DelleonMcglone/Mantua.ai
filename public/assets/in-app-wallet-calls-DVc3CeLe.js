import{b8 as m,b9 as h,cu as p,bY as w,aR as f,cv as T}from"./index-tILzMOs2.js";import{s as b}from"./send-transaction-BQi8LQK8.js";import{r as g}from"./random-CXbs13Cg.js";import"./to-serializable-transaction-BiLHjq5l.js";import"./decodeAbiParameters-CNGCbnoP.js";async function H(c){const{account:t,transactions:o}=c;if(!t)throw new Error("not connected");if(o.length===0)throw new Error("No transactions to send");const s=o[0];if(!s)throw new Error("No transactions to send");if(t.sendBatchTransaction){const n=await Promise.all(o.map(async a=>{const[u,r,e,l]=await Promise.all([m(a),h(a.to),h(a.accessList),h(a.value)]);return{accessList:e,chainId:a.chain.id,data:u,to:r,value:l}}));return{...await t.sendBatchTransaction(n),chain:s.chain,client:s.client}}throw new Error("Account doesn't implement sendBatchTransaction")}async function y(c){const t=await b(c);return p(t)}const d=new w(1e3);async function A(c){const{account:t,calls:o}=c,s=[],n=g(65);if(d.set(n,s),t.sendBatchTransaction){const i=await H({account:t,transactions:o});s.push(i.transactionHash),d.set(n,s)}else for(const i of o){const a=await y({account:t,transaction:i});s.push(a.transactionHash),d.set(n,s)}return n}async function N(c){const{chain:t,client:o,id:s}=c,n=d.get(s);if(!n)throw new Error("Failed to get calls status, unknown bundle id");const i=f({chain:t,client:o});let a="success";const u=await Promise.all(n.map(r=>T(i,{hash:r}).then(e=>({blockHash:e.blockHash,blockNumber:e.blockNumber,gasUsed:e.gasUsed,logs:e.logs.map(l=>({address:l.address,data:l.data,topics:l.topics})),status:e.status,transactionHash:e.transactionHash})).catch(()=>(a="pending",null))));return{atomic:!1,chainId:t.id,id:s,receipts:u.filter(r=>r!==null),status:a,statusCode:200,version:"2.0.0"}}export{N as inAppWalletGetCallsStatus,A as inAppWalletSendCalls};
