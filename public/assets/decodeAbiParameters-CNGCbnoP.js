import{bK as oe,bG as ae,B as R,bF as ce,bR as f,bZ as F,b_ as ue,b$ as le,c0 as de,bq as B,bH as fe,bL as pe,c1 as $,c2 as ye,c3 as he,c4 as me,c5 as be,c6 as ge,c7 as we,c8 as M,aS as P,c9 as $e,ca as ve,cb as xe,bv as Pe,bn as Se,bP as Ae,cc as Ee,cd as ze}from"./index-tILzMOs2.js";const Ie="1.0.8";class d extends Error{constructor(t,n={}){var s;const r=n.cause instanceof d?n.cause.details:(s=n.cause)!=null&&s.message?n.cause.message:n.details,i=n.cause instanceof d&&n.cause.docsPath||n.docsPath,a=[t||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...i?[`Docs: https://abitype.dev${i}`]:[],...r?[`Details: ${r}`]:[],`Version: abitype@${Ie}`].join(`
`);super(a),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"}),n.cause&&(this.cause=n.cause),this.details=r,this.docsPath=i,this.metaMessages=n.metaMessages,this.shortMessage=t}}function b(e,t){const n=e.exec(t);return n==null?void 0:n.groups}const W=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,H=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,K=/^\(.+?\).*?$/,Z=/^tuple(?<array>(\[(\d*)\])*)$/;function T(e){let t=e.type;if(Z.test(e.type)&&"components"in e){t="(";const n=e.components.length;for(let i=0;i<n;i++){const a=e.components[i];t+=T(a),i<n-1&&(t+=", ")}const r=b(Z,e.type);return t+=`)${(r==null?void 0:r.array)??""}`,T({...e,type:t})}return"indexed"in e&&e.indexed&&(t=`${t} indexed`),e.name?`${t} ${e.name}`:t}function z(e){let t="";const n=e.length;for(let r=0;r<n;r++){const i=e[r];t+=T(i),r!==n-1&&(t+=", ")}return t}function Re(e){var t;return e.type==="function"?`function ${e.name}(${z(e.inputs)})${e.stateMutability&&e.stateMutability!=="nonpayable"?` ${e.stateMutability}`:""}${(t=e.outputs)!=null&&t.length?` returns (${z(e.outputs)})`:""}`:e.type==="event"?`event ${e.name}(${z(e.inputs)})`:e.type==="error"?`error ${e.name}(${z(e.inputs)})`:e.type==="constructor"?`constructor(${z(e.inputs)})${e.stateMutability==="payable"?" payable":""}`:e.type==="fallback"?`fallback() external${e.stateMutability==="payable"?" payable":""}`:"receive() external payable"}const J=/^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function Be(e){return J.test(e)}function Me(e){return b(J,e)}const Y=/^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;function Oe(e){return Y.test(e)}function Ue(e){return b(Y,e)}const q=/^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;function Te(e){return q.test(e)}function ke(e){return b(q,e)}const G=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function _e(e){return G.test(e)}function Le(e){return b(G,e)}const Q=/^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;function Ce(e){return Q.test(e)}function je(e){return b(Q,e)}const X=/^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;function Ne(e){return X.test(e)}function Ze(e){return b(X,e)}const Ve=/^receive\(\) external payable$/;function De(e){return Ve.test(e)}const Fe=new Set(["indexed"]),k=new Set(["calldata","memory","storage"]);class Ht extends d{constructor({signature:t}){super("Failed to parse ABI item.",{details:`parseAbiItem(${JSON.stringify(t,null,2)})`,docsPath:"/api/human#parseabiitem-1"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiItemError"})}}class We extends d{constructor({type:t}){super("Unknown type.",{metaMessages:[`Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class He extends d{constructor({type:t}){super("Unknown type.",{metaMessages:[`Type "${t}" is not a valid ABI type.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}class Ke extends d{constructor({param:t}){super("Invalid ABI parameter.",{details:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class Je extends d{constructor({param:t,name:n}){super("Invalid ABI parameter.",{details:t,metaMessages:[`"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class Ye extends d{constructor({param:t,type:n,modifier:r}){super("Invalid ABI parameter.",{details:t,metaMessages:[`Modifier "${r}" not allowed${n?` in "${n}" type`:""}.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class qe extends d{constructor({param:t,type:n,modifier:r}){super("Invalid ABI parameter.",{details:t,metaMessages:[`Modifier "${r}" not allowed${n?` in "${n}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class Ge extends d{constructor({abiParameter:t}){super("Invalid ABI parameter.",{details:JSON.stringify(t,null,2),metaMessages:["ABI parameter type is invalid."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}class A extends d{constructor({signature:t,type:n}){super(`Invalid ${n} signature.`,{details:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class Qe extends d{constructor({signature:t}){super("Unknown signature.",{details:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSignatureError"})}}class Xe extends d{constructor({signature:t}){super("Invalid struct signature.",{details:t,metaMessages:["No properties exist."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}class et extends d{constructor({type:t}){super("Circular reference detected.",{metaMessages:[`Struct "${t}" is a circular reference.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}class tt extends d{constructor({current:t,depth:n}){super("Unbalanced parentheses.",{metaMessages:[`"${t.trim()}" has too many ${n>0?"opening":"closing"} parentheses.`],details:`Depth "${n}"`}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}function nt(e,t,n){let r="";if(n)for(const i of Object.entries(n)){if(!i)continue;let a="";for(const s of i[1])a+=`[${s.type}${s.name?`:${s.name}`:""}]`;r+=`(${i[0]}{${a}})`}return t?`${t}:${e}${r}`:e}const U=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]);function Kt(e,t={}){if(Te(e))return it(e,t);if(Oe(e))return rt(e,t);if(Be(e))return st(e,t);if(Ce(e))return ot(e,t);if(Ne(e))return at(e);if(De(e))return{type:"receive",stateMutability:"payable"};throw new Qe({signature:e})}function it(e,t={}){const n=ke(e);if(!n)throw new A({signature:e,type:"function"});const r=y(n.parameters),i=[],a=r.length;for(let o=0;o<a;o++)i.push(v(r[o],{modifiers:k,structs:t,type:"function"}));const s=[];if(n.returns){const o=y(n.returns),c=o.length;for(let u=0;u<c;u++)s.push(v(o[u],{modifiers:k,structs:t,type:"function"}))}return{name:n.name,type:"function",stateMutability:n.stateMutability??"nonpayable",inputs:i,outputs:s}}function rt(e,t={}){const n=Ue(e);if(!n)throw new A({signature:e,type:"event"});const r=y(n.parameters),i=[],a=r.length;for(let s=0;s<a;s++)i.push(v(r[s],{modifiers:Fe,structs:t,type:"event"}));return{name:n.name,type:"event",inputs:i}}function st(e,t={}){const n=Me(e);if(!n)throw new A({signature:e,type:"error"});const r=y(n.parameters),i=[],a=r.length;for(let s=0;s<a;s++)i.push(v(r[s],{structs:t,type:"error"}));return{name:n.name,type:"error",inputs:i}}function ot(e,t={}){const n=je(e);if(!n)throw new A({signature:e,type:"constructor"});const r=y(n.parameters),i=[],a=r.length;for(let s=0;s<a;s++)i.push(v(r[s],{structs:t,type:"constructor"}));return{type:"constructor",stateMutability:n.stateMutability??"nonpayable",inputs:i}}function at(e){const t=Ze(e);if(!t)throw new A({signature:e,type:"fallback"});return{type:"fallback",stateMutability:t.stateMutability??"nonpayable"}}const ct=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,ut=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,lt=/^u?int$/;function v(e,t){var p,h;const n=nt(e,t==null?void 0:t.type,t==null?void 0:t.structs);if(U.has(n))return U.get(n);const r=K.test(e),i=b(r?ut:ct,e);if(!i)throw new Ke({param:e});if(i.name&&ft(i.name))throw new Je({param:e,name:i.name});const a=i.name?{name:i.name}:{},s=i.modifier==="indexed"?{indexed:!0}:{},o=(t==null?void 0:t.structs)??{};let c,u={};if(r){c="tuple";const g=y(i.type),w=[],E=g.length;for(let O=0;O<E;O++)w.push(v(g[O],{structs:o}));u={components:w}}else if(i.type in o)c="tuple",u={components:o[i.type]};else if(lt.test(i.type))c=`${i.type}256`;else if(c=i.type,(t==null?void 0:t.type)!=="struct"&&!ee(c))throw new He({type:c});if(i.modifier){if(!((h=(p=t==null?void 0:t.modifiers)==null?void 0:p.has)!=null&&h.call(p,i.modifier)))throw new Ye({param:e,type:t==null?void 0:t.type,modifier:i.modifier});if(k.has(i.modifier)&&!pt(c,!!i.array))throw new qe({param:e,type:t==null?void 0:t.type,modifier:i.modifier})}const l={type:`${c}${i.array??""}`,...a,...s,...u};return U.set(n,l),l}function y(e,t=[],n="",r=0){const i=e.trim().length;for(let a=0;a<i;a++){const s=e[a],o=e.slice(a+1);switch(s){case",":return r===0?y(o,[...t,n.trim()]):y(o,t,`${n}${s}`,r);case"(":return y(o,t,`${n}${s}`,r+1);case")":return y(o,t,`${n}${s}`,r-1);default:return y(o,t,`${n}${s}`,r)}}if(n==="")return t;if(r!==0)throw new tt({current:n,depth:r});return t.push(n.trim()),t}function ee(e){return e==="address"||e==="bool"||e==="function"||e==="string"||W.test(e)||H.test(e)}const dt=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;function ft(e){return e==="address"||e==="bool"||e==="function"||e==="string"||e==="tuple"||W.test(e)||H.test(e)||dt.test(e)}function pt(e,t){return t||e==="bytes"||e==="string"||e==="tuple"}function Jt(e){const t={},n=e.length;for(let s=0;s<n;s++){const o=e[s];if(!_e(o))continue;const c=Le(o);if(!c)throw new A({signature:o,type:"struct"});const u=c.properties.split(";"),l=[],p=u.length;for(let h=0;h<p;h++){const w=u[h].trim();if(!w)continue;const E=v(w,{type:"struct"});l.push(E)}if(!l.length)throw new Xe({signature:o});t[c.name]=l}const r={},i=Object.entries(t),a=i.length;for(let s=0;s<a;s++){const[o,c]=i[s];r[o]=te(c,t)}return r}const yt=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function te(e,t,n=new Set){const r=[],i=e.length;for(let a=0;a<i;a++){const s=e[a];if(K.test(s.type))r.push(s);else{const c=b(yt,s.type);if(!(c!=null&&c.type))throw new Ge({abiParameter:s});const{array:u,type:l}=c;if(l in t){if(n.has(l))throw new et({type:l});r.push({...s,type:`tuple${u??""}`,components:te(t[l]??[],t,new Set([...n,l]))})}else if(ee(l))r.push(s);else throw new We({type:l})}}return r}function L(e,{dir:t="left"}={}){let n=typeof e=="string"?e.replace("0x",""):e,r=0;for(let i=0;i<n.length-1&&n[t==="left"?i:n.length-i-1].toString()==="0";i++)r++;return n=t==="left"?n.slice(r):n.slice(0,n.length-r),typeof e=="string"?(n.length===1&&t==="right"&&(n=`${n}0`),`0x${n.length%2===1?`0${n}`:n}`):n}const ht=e=>oe(ae(e));function mt(e){return ht(e)}function bt(e){let t=!0,n="",r=0,i="",a=!1;for(let s=0;s<e.length;s++){const o=e[s];if(["(",")",","].includes(o)&&(t=!0),o==="("&&r++,o===")"&&r--,!!t){if(r===0){if(o===" "&&["event","function",""].includes(i))i="";else if(i+=o,o===")"){a=!0;break}continue}if(o===" "){e[s-1]!==","&&n!==","&&n!==",("&&(n="",t=!1);continue}i+=o,n+=o}}if(!a)throw new R("Unable to normalize signature.");return i}const gt=e=>{const t=typeof e=="string"?e:Re(e);return bt(t)};function wt(e){return mt(gt(e))}function S(e){return typeof e[0]=="string"?vt(e):$t(e)}function $t(e){let t=0;for(const i of e)t+=i.length;const n=new Uint8Array(t);let r=0;for(const i of e)n.set(i,r),r+=i.length;return n}function vt(e){return`0x${e.reduce((t,n)=>t+n.replace("0x",""),"")}`}function ne(e,t,n,{strict:r}={}){return ce(e,{strict:!1})?xt(e,t,n,{strict:r}):se(e,t,n,{strict:r})}function ie(e,t){if(typeof t=="number"&&t>0&&t>f(e)-1)throw new F({offset:t,position:"start",size:f(e)})}function re(e,t,n){if(typeof t=="number"&&typeof n=="number"&&f(e)!==n-t)throw new F({offset:n,position:"end",size:f(e)})}function se(e,t,n,{strict:r}={}){ie(e,t);const i=e.slice(t,n);return r&&re(i,t,n),i}function xt(e,t,n,{strict:r}={}){ie(e,t);const i=`0x${e.replace("0x","").slice((t??0)*2,(n??e.length)*2)}`;return r&&re(i,t,n),i}function Yt(e,t){if(e.length!==t.length)throw new ue({expectedLength:e.length,givenLength:t.length});const n=Pt({params:e,values:t}),r=j(n);return r.length===0?"0x":r}function Pt({params:e,values:t}){const n=[];for(let r=0;r<e.length;r++)n.push(C({param:e[r],value:t[r]}));return n}function C({param:e,value:t}){const n=N(e.type);if(n){const[r,i]=n;return At(t,{length:r,param:{...e,type:i}})}if(e.type==="tuple")return Bt(t,{param:e});if(e.type==="address")return St(t);if(e.type==="bool")return zt(t);if(e.type.startsWith("uint")||e.type.startsWith("int")){const r=e.type.startsWith("int"),[,,i="256"]=le.exec(e.type)??[];return It(t,{signed:r,size:Number(i)})}if(e.type.startsWith("bytes"))return Et(t,{param:e});if(e.type==="string")return Rt(t);throw new de(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function j(e){let t=0;for(let a=0;a<e.length;a++){const{dynamic:s,encoded:o}=e[a];s?t+=32:t+=f(o)}const n=[],r=[];let i=0;for(let a=0;a<e.length;a++){const{dynamic:s,encoded:o}=e[a];s?(n.push(B(t+i,{size:32})),r.push(o),i+=f(o)):n.push(o)}return S([...n,...r])}function St(e){if(!fe(e))throw new pe({address:e});return{dynamic:!1,encoded:$(e.toLowerCase())}}function At(e,{length:t,param:n}){const r=t===null;if(!Array.isArray(e))throw new ye(e);if(!r&&e.length!==t)throw new he({expectedLength:t,givenLength:e.length,type:`${n.type}[${t}]`});let i=!1;const a=[];for(let s=0;s<e.length;s++){const o=C({param:n,value:e[s]});o.dynamic&&(i=!0),a.push(o)}if(r||i){const s=j(a);if(r){const o=B(a.length,{size:32});return{dynamic:!0,encoded:a.length>0?S([o,s]):o}}if(i)return{dynamic:!0,encoded:s}}return{dynamic:!1,encoded:S(a.map(({encoded:s})=>s))}}function Et(e,{param:t}){const[,n]=t.type.split("bytes"),r=f(e);if(!n){let i=e;return r%32!==0&&(i=$(i,{dir:"right",size:Math.ceil((e.length-2)/2/32)*32})),{dynamic:!0,encoded:S([$(B(r,{size:32})),i])}}if(r!==Number.parseInt(n))throw new me({expectedSize:Number.parseInt(n),value:e});return{dynamic:!1,encoded:$(e,{dir:"right"})}}function zt(e){if(typeof e!="boolean")throw new R(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:$(be(e))}}function It(e,{signed:t,size:n=256}){if(typeof n=="number"){const r=2n**(BigInt(n)-(t?1n:0n))-1n,i=t?-r-1n:0n;if(e>r||e<i)throw new ge({max:r.toString(),min:i.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:B(e,{size:32,signed:t})}}function Rt(e){const t=we(e),n=Math.ceil(f(t)/32),r=[];for(let i=0;i<n;i++)r.push($(ne(t,i*32,(i+1)*32),{dir:"right"}));return{dynamic:!0,encoded:S([$(B(f(t),{size:32})),...r])}}function Bt(e,{param:t}){let n=!1;const r=[];for(let i=0;i<t.components.length;i++){const a=t.components[i],s=Array.isArray(e)?i:a.name,o=C({param:a,value:e[s]});r.push(o),o.dynamic&&(n=!0)}return{dynamic:n,encoded:n?j(r):S(r.map(({encoded:i})=>i))}}function N(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}const qt=e=>ne(wt(e),0,4);class V extends R{constructor({offset:t}){super(`Offset \`${t}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class Mt extends R{constructor({length:t,position:n}){super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`,{name:"PositionOutOfBoundsError"})}}class Ot extends R{constructor({count:t,limit:n}){super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`,{name:"RecursiveReadLimitExceededError"})}}const Ut={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new Ot({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new Mt({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new V({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new V({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,e&255),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function Tt(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(Ut);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}function kt(e,t={}){typeof t.size<"u"&&M(e,{size:t.size});const n=P(e,t);return $e(n,t)}function _t(e,t={}){let n=e;if(typeof t.size<"u"&&(M(n,{size:t.size}),n=L(n)),n.length>1||n[0]>1)throw new ve(n);return!!n[0]}function m(e,t={}){typeof t.size<"u"&&M(e,{size:t.size});const n=P(e,t);return xe(n,t)}function Lt(e,t={}){let n=e;return typeof t.size<"u"&&(M(n,{size:t.size}),n=L(n,{dir:"right"})),new TextDecoder().decode(n)}function Gt(e,t){const n=typeof t=="string"?Pe(t):t,r=Tt(n);if(f(n)===0&&e.length>0)throw new Se;if(f(t)&&f(t)<32)throw new Ae({data:typeof t=="string"?t:P(t),params:e,size:f(t)});let i=0;const a=[];for(let s=0;s<e.length;++s){const o=e[s];r.setPosition(i);const[c,u]=x(r,o,{staticPosition:0});i+=u,a.push(c)}return a}function x(e,t,{staticPosition:n}){const r=N(t.type);if(r){const[i,a]=r;return jt(e,{...t,type:a},{length:i,staticPosition:n})}if(t.type==="tuple")return Dt(e,t,{staticPosition:n});if(t.type==="address")return Ct(e);if(t.type==="bool")return Nt(e);if(t.type.startsWith("bytes"))return Zt(e,t,{staticPosition:n});if(t.type.startsWith("uint")||t.type.startsWith("int"))return Vt(e,t);if(t.type==="string")return Ft(e,{staticPosition:n});throw new Ee(t.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const D=32,_=32;function Ct(e){const t=e.readBytes(32);return[ze(P(se(t,-20))),32]}function jt(e,t,{length:n,staticPosition:r}){if(!n){const s=m(e.readBytes(_)),o=r+s,c=o+D;e.setPosition(o);const u=m(e.readBytes(D)),l=I(t);let p=0;const h=[];for(let g=0;g<u;++g){e.setPosition(c+(l?g*32:p));const[w,E]=x(e,t,{staticPosition:c});p+=E,h.push(w)}return e.setPosition(r+32),[h,32]}if(I(t)){const s=m(e.readBytes(_)),o=r+s,c=[];for(let u=0;u<n;++u){e.setPosition(o+u*32);const[l]=x(e,t,{staticPosition:o});c.push(l)}return e.setPosition(r+32),[c,32]}let i=0;const a=[];for(let s=0;s<n;++s){const[o,c]=x(e,t,{staticPosition:r+i});i+=c,a.push(o)}return[a,i]}function Nt(e){return[_t(e.readBytes(32),{size:32}),32]}function Zt(e,t,{staticPosition:n}){const[r,i]=t.type.split("bytes");if(!i){const s=m(e.readBytes(32));e.setPosition(n+s);const o=m(e.readBytes(32));if(o===0)return e.setPosition(n+32),["0x",32];const c=e.readBytes(o);return e.setPosition(n+32),[P(c),32]}return[P(e.readBytes(Number.parseInt(i),32)),32]}function Vt(e,t){const n=t.type.startsWith("int"),r=Number.parseInt(t.type.split("int")[1]||"256"),i=e.readBytes(32);return[r>48?kt(i,{signed:n}):m(i,{signed:n}),32]}function Dt(e,t,{staticPosition:n}){const r=t.components.length===0||t.components.some(({name:s})=>!s),i=r?[]:{};let a=0;if(I(t)){const s=m(e.readBytes(_)),o=n+s;for(let c=0;c<t.components.length;++c){const u=t.components[c];e.setPosition(o+a);const[l,p]=x(e,u,{staticPosition:o});a+=p,i[r?c:u==null?void 0:u.name]=l}return e.setPosition(n+32),[i,32]}for(let s=0;s<t.components.length;++s){const o=t.components[s],[c,u]=x(e,o,{staticPosition:n});i[r?s:o==null?void 0:o.name]=c,a+=u}return[i,a]}function Ft(e,{staticPosition:t}){const n=m(e.readBytes(32)),r=t+n;e.setPosition(r);const i=m(e.readBytes(32));if(i===0)return e.setPosition(t+32),["",32];const a=e.readBytes(i,32),s=Lt(L(a));return e.setPosition(t+32),[s,32]}function I(e){var r;const{type:t}=e;if(t==="string"||t==="bytes"||t.endsWith("[]"))return!0;if(t==="tuple")return(r=e.components)==null?void 0:r.some(I);const n=N(e.type);return!!(n&&I({...e,type:n[1]}))}export{Ht as I,Mt as P,Kt as a,Tt as b,S as c,Gt as d,wt as e,Re as f,Yt as g,_e as i,Jt as p,ne as s,qt as t};
